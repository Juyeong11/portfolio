형식 추론

const int c{};
auto a2 = c; -> 여기서 a2의 타입은 무엇일까?

auto와 templete는 동일한 규칙을 사용한다.
decltype은 조금 다름

추론된 타입 조사 방법
1. typeid -> const/volatile/reference 가 출력안됨
2. 에러 메시지
3. boost::type_index
4. 컴파일러 메크로
	__FUNCSIG__ (vs 컴파일러, g++이면 찾아보자)

1. 템플릿 형식 연역 규칙을 숙지하라
	template<typename <T>>
	void f(Paramtype param)
	
	(Expr) x{};
	f(x);
	
	이때 T는 전달받은 값의 Expr과 Paramtype에 의해 영향을 받고 이는 아래 3가지 경우에 따라 추론 규칙이 달라진다.
		Template에서 형식 추론할 때 매개변수의 형식에 따라 const속성 유지 여부가 달라진다.
		
	1. Paramtype이 포인터 또는 참조 형식이지만 보편잠조는 아닌경우	// Paramtype이 r-reference일 때
		함수인자의 reference를 제거하고 T타입 결정
		const, volatile속성은 유지
	2. ParamType이 보편참조인 경우							// Paramtype이 l-reference일 때
	3. ParamType이 포인터도 아니고 참조도 아닌 경우				// Paramtype이 값으로 전달일 때
		인자의 const, volatile, reference를 제거하고 T타입을 결정 (인자가 가르키는 곳의 const속성은 유지된다.(const char* const))
		함수를 값으로 전달할 때의 프로그래머의 의도를 생각해보자 -> 복사본을 만들어 값을 마음대로 변경하기 위해 값으로 전달한다. 이때 c/v/r 속성이 남아 있게되면 의도대로 사용할 수 없게 된다.
		
	expr이 배열인 경우
		Paramtype이 T인 경우 	T는 포인터
		Paramtype이 T&인 경우 T는 배열 Paramtype은 배열을 가르키는 참조
	
	3. 규칙을 보고 아래의 T값을 추론해보자
	// ParamType이 T일때
	template<typename <T>>
	void f(T param)
	{}
	int n{};					f(n);	//	T: 				Paramtype:
	int& r = n;					f(r);	//	T: 				Paramtype:	
	const int c = 10;			f(c);	//	T: 				Paramtype:
	const int& cr = c;			f(cr);	//	T: 				Paramtype:
	const char* const cc = "a";	f(cc);	//	T: 				Paramtype:
	
	// ParamType이 T&일 때
	template<typename <T>>
	void f(T& param)
	int n{};					f(n);	//	T: int			Paramtype: int
	int& r = n;					f(r);	//	T: int			Paramtype: int&
	const int c = 10;			f(c);	//	T: const int	Paramtype: const int&
	const int& cr = c;			f(cr);	//	T: const int	Paramtype: cosnt int&
	
	// ParamType이 T&&일 때
	일단 ref collapsing을 적용해 보자
	int& & & & -> &가 4개 있을 때만 &&값이다.

2. auto의 형식 연역 규칙을 숙지하라
	대부분 Template과 동일하지만
	auto a = {1};인 경우는 auto는 initializer_list로 추론된다. Template의 경우 빌드 오류
	

3.decltype의 작동 방식을 숙지하라
	()안에 표현식의 이름만 있는 경우
		이름의 선언과 완전히 동일하게 나온다.
	()표현식의 이름과 연산자가 있는 경우
		표현식의 결과가 l-value가 될 수 없으면
			값 타입
		표현식의 결과가 l-value가 될 수 있으면
			참조 타입
		
	decltype(함수)	: 함수 타입
	decltype(함수 이름): 함수의 실행 결과 즉 함수의 반환 타입
		auto a = decltype(f()); 일때 f가 참조를 리턴하면 auto는 참조 속성을 제거한 표현식을 추론한다. 참조 속성을 유지하고 싶다면 decltype(auto)를 사용하자.
		
	decltype(auto)는 함수의 반환 값으로도 사용할 수 있다. -> 함수의 실행 결과에 따라 반환 타입을 정할 수 있음
	
4. 연역된 형식을 파악하는 방법을 알아두라
	1. typeid -> const/volatile/reference 가 출력안됨
	2. 에러 메시지
	3. boost::type_index
	4. 컴파일러 메크로
		__FUNCSIG__ (vs 컴파일러, g++이면 찾아보자)
		
		
2장
auto

5. 명시적 형식 선언보다는 auto를 선호하라
	프로그래머의 실수를 줄여줄 수 있으며,									ex) auto a; -> 초기화 되지 않은 변수 사용을 막을 수 있다.
	경우에 따라 명시적 선언이 메모리와 수행 시간을 더 쓸 수 있고,					ex) 람다를 function로 받는 경우
	잘못 선언된 경우 암시적 형변환이 발생하며 의도치 않은 결과가 나올 수 있다.		ex) const 속성이 있는 객체를 그냥 받을 경우 내부적으로 임시 객체를 생성하는 등 과정이 발생한다.

	다만 auto의 경우 참조를 제거하는 특징이 있고 {}초기화를 사용하면 initializer_list로 반환된다는 것을 알고 있자.
	
6. auto가 원치 않은 형식으로 연역될 때에는 명시적 형식의 초기치를 사용하라
	그 예시로 vector<bool>의 경우 bool의 배열이 아니라 비트 단위로 저장되고 있으며 vector<bool>의 oprator[]는 bool&인 것 처럼 행동하는 Proxy를 반환해준다.
	그러므로 vector<bool>에 auto를 사용하게 되면 Proxy의 형식이 추론되며 이는 예상치 못한 결과를 나타낼 수 있다.
	만약 auto가 원치 않는 형식으로 추론되고 있다면 static_cast를 사용해 초기 형식을 정해주자.
	

3장
현재적 C++에 적응하기
7. 객체 생성 시 괄호()와 중괄호{}를 구분하라
	 C++에서는 객체를 초기화에서 값을 지정하는 방법이 3가지 있다. int a(0); int a{}; int a = 0; 
	 이때 복사가 불가능한 객체는 ()를 사용할 수 없으며 객체의 속성에 관계없이 모든 곳에 사용할 수 있게 만들어진 것이 {}(uniform initialization)이다.
	 
	 ()연산자의 경우 함수의 선언에도 사용되기 때문에 컴파일러가 프로그래머의 의도와 다르게 해석할 여지가 있다.
	 {}연산자의 경우 auto를 사용할 때 불편하며 또한 생성자에 Initializer_list를 받는 생성자가 있다면 암시적 변환이 가능한 모든 경우를 해당 생성자가 호출되는 문제가 있다.
	 
	 이 둘의 차이를 알고 잘 사용하자 끝!
	 
8. 0과 NULL보다 nullptr을 선호하라
	0과 NULL은 포인터가 아니다 끝!

9. typedef보다 using(별칭 선언)을 선호하라
	c++11부터는 using이라는 것을 typedef와 동일하게 사용할 수 있다.
	이 둘은 무슨 차이가 있길래 using을 사용하라는 것일까ㅣ?
	c++ 규칙중 템플릿에 의해 typedef로 선언된 변수가 T에 의존적인 경우에는 무조건 앞에 typename을 붙여야하는 규칙이 있다.
	또한 구조체로 만들어야하므로 선언부에 구조체에 선언된 변수명도 적어줘야한다.
	using이 쓰기 편하다 끝!
	
10. 범위 없는 enum보다 범위 있는 enum을 선호하라
	enum class를 사용하자
		전방선언이 가능해 컴파일 타임을 줄일 수 있고 범위를 지정해야만 접근이 가능해 enum처럼 해당 값을 변수명으로 못쓴다거나 하는 문제가 없다.
	바탕 형식(underlying type)이 뭐지? -> enum을 담을 변수형을 말한다. enum의 경우 기본 형식이 없어 컴파일러마다 다르게 설정되고, enum class의 경우 int가 기본형식으로 지정된다.

11. 정의되지 않은 비공개 함수보다 삭제된 함수를 선호하라
	private으로 선언해 함수 사용을 막는거 보다 c++11에 추가된 = delete를 사용하여 함수사용을 막자
	에러메시지에 오해의 소지가 없다.
	
12. 재정의 함수들은 override로 선언하라
	virtual함수를 override하기 위해서는 const, 함수 이름, 예외 여부, 매개변수 형식, 참조 한정사 등이 모두 동일해아한다.
	만약 기반 클래스에서 파생 클래스로 override되고 있던 함수의 속성이 변경되었다 가정해보자 이때 파생 클래스에 override 키워드를 사용하지 않았다면 컴파일러는 경고조차 하지 않고 컴파일 할 수 도 있다.
	
13. iterator보다 const_iterator를 선호하라
	그냥 과거에는 const 반복자를 쓰기 어려웠다는 설명만 있네...아무튼 const_iterator를 쓰자. const를 사용하자는 것과 같은 이치
	
14. 예외를 방출하지 않을 함수는 noexcept로 선언하라.
	예외가 던저졌을 시 해당 함수의 호출 스택은 예외를 받고 있는 함수까지 풀리게 된다. 
	이러한 동작을 할 수 있기 때문에 예외를 던지고 말고의 차이는 컴파일러의 최적화에 큰 영향을 끼친다.
		vector는 push_back시 할당된 메모리 공간이 부족하다면 새로 할당하고 기존의 자료를 이동 혹은 복사한다.
		이때 이동, 복사 중 하나를 결정하는 요소가 noexcept인지 여부이다.
		왜냐하면 이동을 했을 경우 중간에 예외가 발생하게 된다면 원본은 이미 이동을 해 사라진 상태이기 때문에 복구가 힘들기 때문이다.(복사의 경우는 모두 복사하고 원본을 제거하기 때문에 상관없다.)
		swap또한 마찬가지
	noexcept의 경우 호출되는 함수의 noexcept여부에 따라 결정할 수 도 있다.

15. 가능하다면 항상 constexpr을 사용하라
	컴파일시간에 결정되는 값은 constexpr을 사용하자
	
16. const 멤버 함수를 스레드에 안전하게 작성하라
	mutable을 써서 멤버 변수를 바꾸면서 그런 소리를 하네?? mutable을 사용하지 않으면 되는 것을...

17. 생성, 소멸, 복사, 이동관련 함수의 자동 작성 조건을 숙지하라
	이동 생성자, 이동 대입 연산자는 둘 중 하나라도 선언되어 있으면 자동으로 생성되지 않는다.(소멸자가 선언되어 있어도 생성되지 않는다.)
	또한 복사 연산 중 하나라도 선언되어 있어도 이동 연산은 작성되지 않는다. 그 반대도 마찬가지(이동이 선언되는 경우 복사 연산도 생성되지 않는다.)
	Rule of three를 생각하자.
	
4. 스마트 포인터
18. 소유권 독점 자원의 관리에는 unique_ptr를 사용하라
	unique_ptr은 raw pointer와 동일한 성능을 보장하며 더욱 안전하다
	
19. 소유권 공유 자원의 관리에는 std::shared_ptr을 사용하라.
	make_shared를 사용해야하는 이유 -> shared_ptr의 참조 계수, 삭제자 등 객체 기능을 위해 필요한 것은 힙에 할당된다. 
	-> 이는 똑같은 포인터를 사용해 다른 shared_ptr을 만든다면 힙에 할당된 제어 블록이 2개가 되는 것이다. -> 나중에 하나가 삭제되면 댕글링포인터가 생긴다.
	
20. std::shared_ptr처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하다면 std::weak_ptr를 사용하라
		shared_ptr은 소멸할때 자신이 가르키고 있는 객체의 참조 개수를 하나 줄이면서 소멸하고, 이 때 참조 개수가 0이라면 해당 객체를 제거하면서 소멸한다.
		weak_ptr은 shared_ptr에 의해서만 생성될 수 있고, shared_ptr의 참조 개수에 영향을 주지 않는다.
		또한 역참조가 불가능하여 가르키는 자원을 사용하기 위해서는 shared_ptr로 변경한 뒤 사용해야 하기 때문에 가르키는 자원의 존재 여부를 무조건 확인할 수 밖에 없다. 
	
	예시 1.
	캐시처럼 해당 자원에 빠르게 접근하기 위해 자원의 포인터를 저장한 자료구조가 있다고 생각해보자. 
	이 캐시 자료구조에 저장된 포인터는 원본 자원이 제거된다면 같이 제거가 되어야하며 캐시의 포인터가 제거된다고 해도 원본 포인터의 객체가 제거되는 일은 없어야한다.
	
	이 자료구조를 만약 shared_ptr로 만든다면 원본의 삭제를 원해도 캐시에 남아있다면 삭제되지 않는 문제가 생긴다. 이 문제를 해결하기 위해서는 weak_ptr를 사용하면 된다.
	weak_ptr를 사용하면 원본 자원이 사라진 경우도 자연스럽게 확인할 수 있고 캐시의 포인터가 제거된다해도 원본에는 영향을 끼치지 않기 때문이다.
	
	예시 2.
	B라는 객체를 A와 C가 shared_ptr로 가르키고 있고, 이때 A와 B를 shared_ptr이 서로를 가르키고 있다고 생각해보자 A <-> B <- C
	shared_ptr로 관리되는 자원의 수명은 참조 개수로 정해지고, 정상적으로는 참조개수는 객체의 소멸자가 호출될 때 감소된다.
	그렇다면 여기서 A를 파괴하려면 어떻게 해야할까? -> 위와 같은 상황에서는 소멸자를 이용해 참조 개수를 줄이는 방법으로는 제거할 수 없다. 소멸자는 정상적인 상황이라면 딱 한 번만 호출되게 되어있기 때문이다
	A를 제거하려 해보자 B의 소멸자를 호출해 A의 참조 개수를 0으로 만들어야하고 그러기 위해서는 B의 소유권을 가지고 있는 A와C의 소멸자가 호출되어야 한다.
	여기서 A의 소멸자를 호출하기 위해서는 B의 소멸자가 2번 호출되어야 해 제거가 안된다. C의 소멸자를 호출하는 경우도 마찬가지이다. C가 소멸될 당시에 B는 참조계수가 2이기 때문에 A와 B가 서로를 참조한채로 남게되고 정상적인 방법으로는 A와 B의 소멸자를 호출할 방법이 없다.
	
	이때 B에서 A를 가르키는 포인터를 weak_ptr로 생성한다면 이런 순환 관계가 생기지 않고 A를 가르키는 객체가 소멸되어 B의 Weak_ptr만 남았다면 A가 자연스럽게 제거되고 B는 A가 제거된 것을 알 수 있기 때문에 잘못된 곳을 참조할 위험도 사라지게 된다.
	
21. new를 직접 사용하는 것보다 std::make_unique와 std::make_shared를 선호하라
	shared_ptr의 경우 make를 사용하면 new를 사용하는 것 보다 더 빠르다 -> 제어블럭 할당과 관련된 최적화가 있다고 하는데 정확하게 뭔지는 모르겠음
	make를 사용할 수 없는 경우가 있다 -> 삭제자를 지정해야하는경우, weak_ptr의 shared_ptr보다 오래 살아남는 경우
	
22. Pimpl 관용구를 사용할 때에는 특수 멤버 함수들을 구현파일에서 정의하라
	컴파일 시간을 줄이기 위해 pimpl를 사용해 보았을 것이다. 이때 Pimpl 는 포인터를 사용하게 되는데 이것을 스마트 포인터로 관리하려 한다면 어떻게 될까?
	만약 이것을 unique_ptr을 이용해 관리한다면 선언부에 전방선언된 형태의 impl 클래스를 포인터로 가지게 될 것이다. 
	이때 impl클래스를 가지고 있는 클래스는 사용자가 별다른 조치를 하지 않았다면 구현부에 생성자, 소멸자 등의 특수 멤버함수를 생성하였을 것이다.
	여기서 빌드 에러가 발생하게 된다.
	unique_ptr는 삭제되기 위해서는 자신이 관리하는 포인터의 형식이 무엇인지 정확하게 알고 있어야 한다. 그렇기 때문에 자동으로 생성되는 소멸자가 선언부에 있다면 포인터 형식을 몰라 빌드가 안되는 문제가 생긴다.
	shared_ptr은 해당 사항이 없는데 이 차이점은 내부 구현의 차이에 있는 것 같다.
	
	아무튼 unique_ptr을 전방선언된 객체 관리에 사용한다면 소멸자와 이동생성자를 구현부에 만들어 주자.
	
우측값 참조, 이동 의미론, perfect forwarding
	위 3가지에 대해 정확하게 이해해보자

23. std::move와 std::forward를 숙지하라
	move는 type T를 T&&로 캐스팅 해주는 함수이다.
	forward는 특정 조건(전달 받은 인자가 오른값일 경우)에서 다시 오른값으로 캐스팅해주는 함수이다. -> 함수 인자로 넘어오면 이름을 가지게되 왼값이 된다. -> 전달 받은 인자가 오른값이였는지는 매개변수에 저장되어 전달된다.
	
	move(_Ty&& _Arg) -> 매개변수를 이렇게 받기때문에 인자의 const속성이 유지된다. 즉 const인자를 move하게되면 const int&&이런 식으로 캐스팅 되어 우측값으로 사용할 수 없게된다.
	
24. 보편참조와 오른값 참조를 구별하라
	void f(T&& ) 함수에서 T는 참조가 될 수 있고 우측값도 될 수 있다 이러한 것을 보편 참조라고 하자
	int&& 의 경우는 우측값만을 받을 수 있는 것이 확실하다. 

25. 오른값 참조에는 std::move를 보편 참조에는 forward를 사용하라
	만약 템플릿 함수 인자로 T&&와 같은 매개변수가 있다면 std::move를 이용해 해당 값을 이동하려고 하지 말자 T&&은 우측값 외 좌측값도 받을 수 있기 때문에 지역 변수와 같은 것을 인자로 넘겨주는 경우 예상하지 못한 결과가 나오게 된다.
	만약 move가 필요한 경우에는 forward를 사용해 우측값 일 때만 move를 하도록 하자.
	
	반환값 최적화를 고려하자 -> 지역 변수를 리턴하는 함수의 반환값에 move를 사용하지 말자 컴파일러가 해주는 최적화(RVO)를 사용할 수 없게 된다.
	
26. 보편 참조에 대한 오버로딩를 피하라
	T&& 인자로 받는 함수를 만들었다면 해당 함수에 대한 오버로딩은 피하자 T&&는 거의 대부분의 형식을 추론할 수 있어 사용자가 예상치 못한 동작을 할 수 있다.

27. 보편 참조에 대한 오버로딩대신 사용할 수 있는 기법을 알아두라
	const T&, 값 전달 방식, tag dispatch 방법을 이용해 T&&매개변수를 받는 함수를 호출하는 인자를 제한할 수 있다.
	is_same, decay, enable_if, is_base_of, remove_reference를 사용해 T&&인자에 대한 조건을 프로그래머가 지정할 수 있다.
	왜 이렇게까지 해서 템플릿을 쓰는거야...
	
28. 참조 축약(reference collapsing)을 숙지하라
	T&&인자에 T가 어떤 식으로 추론되는지 정확하게 모르고 있는 것 같다. 좀 더 공부하자
	아무튼T&&인자의 T가 추론될 때 인자가 좌측값이면 T는 참조로 추론되어 T& && 형태가 되고 이는 참조 축약에 의해 T&로 추론된다. 만약 인자가 우측값이라면 T는 우측값으로 추론되고 T&& && 형태가 되어 T&&로 추론된다.
	이렇게 인자가 좌측값이냐 우측값이냐에 따라 T의 참조 여부가 결정된다.
	이 인자를 remove_reference를 한 뒤 &&로 static_cast를 하게되면 우리가 알고 있는 forward가 구현되는 것이다. 
	
29. 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 생각하라.
	이동 연산이 적용되지 않는 경우와 생각만큼 효율적으로 동작하지 않는 경우가 있다. 
	std::array, std::string(문자열 길이가 작은 경우), noexcept이 아닌 경우이며
	이동연산이 복사보다 효율적인 이유는 포인터만 복사하면 되기 때문이며 이동 연산자가 있고 noexcept로 선언되어 있어야 사용된다는 것을 생각하면서 사용하자.
	
30. perfect forwarding 이 실패하는 경우를 잘 알아둬라
	perfect forwarding은 단순히 객체를 전달하는 것만 아니라 그 객체의 주요 특징(const, volatile, 우측값 여부)까지 전달하는 것을 말한다.
	T&&와 std::forward를 사용하는 이 방법은 인자로 initializer_list, 0 NULL로 표현된 포인터, 선언만 된 static const 멤버 변수, 오버로딩된 함수 포인터, 비트 필드 가 넘어오면 실패한다.
	
	static const 멤버 변수는 컴파일 시 사용된 곳에 값으로 치환되어 적용되기 때문에 변수가 저장될 공간이 필요하지 않다. 하지만 이 변수의 주소를 통해 접근하는 코드가 있다면 해당 공간을 정의해 사용해야 한다.

람다 표현식	
임시객체
mutable
[]<typename T>(T& a, T&b) mutable { return a + b; }
31. 기본 캡쳐 모드를 피하라
	값을 복사하여 람다 클래스에 저장하는 기본 캡쳐 모드는 값을 복사하기 때문에 문제가 없을 것 같지만 문제가 생길 수 있다.
	포인터를 복사하는 경우, static 변수를 복사하는 경우 복사된 멤버의 수명은 람다 객체에 수명과 상관 없이 제거될 수 있다.
	객체의 멤버 변수를 캡쳐하는 경우 this 포인터가 사용되기 때문에 기본 캡쳐된 변수의 유효성은 클래스의 수명에 달려있으며 static변수의 경우 별도로 복사해서 넣지 않는 한 static성질이 유지된다.

32. 객체를 클로저 안으로 이동(move)하려면 초기화 캡쳐를 사용하라.
	복사보다 이동이 저렴한 객체를 람다에 전달하기 위해서는 [p = std::move(p)](){} 형식의 초기화 캡쳐를 이용하라
	std::bind를 이용해 비슷하게 구현할 수 있다.(이건 넘어가자)
	
33. std::forward를 통해서 전달할 auto&& 매개변수에는 decltype을 사용하라.
	c++14 부터는 람다 매개변수에 auto를 사용할 수 있게 되었다. 이 매개변수를 완벽하게 전달하는 것이 필요하다면 std::forward에 decltype을 사용해 완벽한 전달이 가능하다.
	[](auto&& x){ return func(std::forward<(decltype(x)>(x)); }
	
34. std::bind보다 람다를 선호하라.
	람다가 bind를 완벽하게 대체할 수 있다.
	넘어가자

std::variant가 뭐지?
	std::variant는 union 과 똑같이 행동하지만, 타입에 안전합니다... 이런게 있구만
	
동시성 API
async, future, thread, mutex, atomic, condition_variable ...?

35. 스레드 기반 프로그래밍보다 과제 기반 프로그래밍을 선호하라
	std::thread std::async의 차이점 thread는 새로운 스레드를 만들어 작업을 할당, async는 작업을 스케줄러에게 알아서 해달라 한다.
	async를 사용하는 경우 스레드를 직접 관리하지 않기 때문에 스레드 고갈, oversubscription, 부하 균형 등의 문제를 신경쓰지 않아도 된다.
	하지만 스레드를 직접 다루는 것이 적합한 경우도 존재한다.

36. 비동기성이 필수일 때는 std::launch::async를 지정하라.
	async는 옵션을 설정해 무조건 스레드를 생성할지, get 이나 wait가 호출될 때 실행할 지 정할 수 있다. 잘 알아보고 설정하자.
	
37. std::thread를 모든 경로에서 join불가능하도록 만들어라
38. 스레드 핸들 소멸자의 다양한 행동 방식을 주의하라
39. 한 번만 발생하는 이벤트 통신에는 void promis 사용을 고려하라
40. atomic과 volatile 차이점
41. 이동이 저렴하고 항상 복사되는 매개변수는 값 전달을 고려하라
42. push 보다 emplace를 고려하라