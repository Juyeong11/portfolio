HelloUnreal

Unreal C++ 코딩 표준
이름 규칙
	클래스의 시작은 public으로
	소문자는 가급적 사용하지 않고 공백, _ 없게 (파스칼 케이싱)
	모든 클래스와 구조체는 고유한 접두사를 사용 ( U UnrealObject, A Actor, S Widget, I, b(소문자) bool, E enum, F 그외)
코드 명확성
	파라미터에 가급적 In Out 접두사 사용
	const 적극적으로 사용
	레퍼런스를 통한 복사방지
	auto키워드 사용 자제 -> 이터레이터의 경우 문제가 없다고 판단될 경우 사용가능
	override, final 사용 강력히 권장
	nullptr사용!!
	중괄호는 무조건 다음줄
C++ 라이브러리
	C++17을 사용한다.
	int형의 경우 그대로 사용하지 않고 uint8 같이 크기를 명확하게 알려주는 방식을 사용한다.
	표준 라이브러리를 사용하지 않고 언리얼에서 제작한 것을 사용 -> std::move -> MoveTemp
		점차 표준 라이브러리로 변경할 예정이지만 현재는 사용되지 않는다는 것을 알고 있자
		atomic의 경우 표준을 사용한다?
		traits의 경우 C++은 value, type과 같이 소문자를 사용하지만 UE 레거시의 경우 Value와 Type만을 지원한다. 새로 추가되는 것들은 대/소문자를 모두 지원함
		regex의 경우 UE에서 제작한 것이 없으므로 캡슐화해서 잘 사용하자
		limits numerric_limits는 온전히 사용할 수 있다.
		cmath는 부동 소수점 비교 함수만 사용할 수 있다.
		
		표준 컨테이너와 스트링은 interop code를 제외하고는 사용하지 말아야한다.
			interop code가 어떤 것이 있는지 왜 안 알려줘...?
코멘트 규칙
	코멘트를 자동으로 추출하여 문서로 만들고 있어서 코멘트에 규칙이 있다네요...
	이건 나중에 소스코드를 볼 일 있으면 확인해보자
	

Find in Files를 많이 사용하기 때문에 포인터, 레퍼런스의 경우 변수명의 바로 뒤에 공백없이 넣어줘 바로 찾을 수 있도록
헤더 파일 및 include 구문은 의존성을 최소화시키도록 고민할 것

상황에 따라 못 지킬 수 있을 것 같지만 정리되어 있는 규칙들 
	모든 변수는 하나의 단어로 설명되도록 한 번에 하나씩만 선언해야한다.
	
	
Unreal C++ 기본 타입과문자열
	C++소스코드에 영어와 다른 문자를 가급적 쓰지말자 찾기 힘든 컴파일 오류가 날 수 있다. -> 꼭 써야할 경우 UTF-8로 저장하자.
	FString, TCHAR, 
	FName 에셋을 관리하기 위한 문자열 해쉬를 사용해 문자열을 빨리 찾을 수 있다. -> 선언되면 Global FNamePool에 저장된다.
	FText UI용

Unreal 오브젝트들
	언리얼은 성능과 유지보수 두 가지를 모두 가져가기 위해 C++를 이용해 C#, Java처럼 안정성을 위해 다양한 기능을 추가한 오브젝트를 지원한다.(리플리케이션, 델리게이트, 인터페이스)
	이러한 오브텍트의 접두사는 U이고 일반 C++오브젝트의 접두사는 F이다.
	
	오브젝트를 언리얼 오브젝트로 만들기 위해서는 UClass 메크로를 사용해야하며 이렇게 하면 다양한 기능이 추가된다.
	클래스 기본 객체(CDO)				: 클래스의 기본 값과 타입 정보 제공
	리플렉션(Reflection)				: 런타임에 클래스 정보 참조 기능
	인터페이스(Interface)				: 클래스 인터페이스 제공
	향상된 열거형
	델리게이트(Deligate)				: 객체간 결합을 낯출 수 있는 델리게이트 기능 제공
	가비지컬렉션(Garbage Collection)	: 자동 메모리 관리
	향샹된 구조체(Struct)				: 리플렉션 가능한 구조체
	직렬화(Serialization)				: 객체 정보를 바이트 스트림으로 저장, 전송, 읽는 기술
	
	언리얼 오브젝트 선언 방법
	UCLASS
	PrjName_API		: 다른 모듈에서 사용할 수 있도록 해주는 메크로
	GENERATED_BODY	: 클래스 정보를 모아 문자열로 만든다.
	
	언리얼 리플렉션 시스템
	각 멤버에 아래 매크로를 추가해주면 언리얼에 의해 관리가 되고 언리얼에서 지원해주는 여러가지 기능을 사용할 수 있게 된다.
	UPRORERTY()
	UFUNTHION()
	가비지 컬랙션, 리플리케이션, 형변환 등등...
	
	언리얼 오브젝트에는 항상 클래스 정보를 담은 UClass 객체가 매핑되어 있다.
	UClass로부터 언리얼 오브젝트의 정보를 파악할 수 있음
	UClass에는 클래스 기본 오브젝트(CDO)가 연결되어 있다. -> 어디에 쓰는데? -> 클래스 이름을 가지고 접근할 수 있다. -> 이걸 어따써...?
	클래스 정보와 CDO는 엔진 초기화 과정에서 생성			-> 왜 그러는데? 어떻게 이렇게 되는거지?
	헤더 정보를 변경하거나 생성자 정보를 변경하면 에디터르 끄고 컴파일하자. -> 왜??
	
	
	언리얼 인터페이스
	C++의 추상인터페이스와는 다르게 순수 가상 함수만 선언해야하는 것은 아니다.
	인터페이스를 생성하면 UClass와 IClass가 생성되는데 이때 UClass는 클래스 타입을 저장하기 위해 생성되는 것이고, 사용할 일 없다. -> 헤더 툴과 관련이 있는 것일까? -> 인터페이스로 어떤 기능을 지원하기위해 타입정보를 저장하는 거지?
	
	언리얼 컴포지션
	Is-A Has-A Solid 기법을 이용해 객체 설계를 한다.
	언리얼에서 컴포지션을 구현하는 방법은 2가지가 있다. ClassDefaultObject에 미리 언리얼 오브젝트를 생성해 조합한다. CDO에 빈포인터만 넣고 런타임에 생성한다.
	내가 소유한 오브젝트는 Subobject 나를 소유한 오브젝트를 Outer
	
	언리얼 델리게이트
	클래스간 느슨한 결합을 위해 인터페이스를 이용해 동작을 선언하고 각 클래스에서 인터에이스를 상속해 동작을 구현해 사용할 수 있다.
	하지만 이 방법은 인터페이스를 만들어야하는 불편함이 있다.
	이 불편함을 해결하기 위해 언리얼에서는 델리게이트를 사용한다. -> 멤버함수를 어딘가에 바인드하여 객체를 몰라도 해당 멤버함수를 호출할 수 있다. -> 편하긴 하겠다만 이게 느슨한 결합과 무슨상관?
	그냥 클래스간 결합을 다른 클래스에 떠넘기는거 아닌가...
	
	델리게이트 구현이 어떻게되는걸까?
	
	멤버 함수 포인터 연결해줌... 브로드캐스트시 연결된 함수 확인
	
	언리얼 컨테이너 UCL
	std의 자료구조와 다르다.
	TArray, TSet, TMap
	
	TArray -> std::vector와 유사하다 각 멤버함수는 문서를 참고하자,
		sort가 알고리즘 별로 구현되어있다. 
		RemoveSwap이 있어서 순서가 상관없다면 사용할 수 있는 remove도 있음
		
	
	TSet -> 이진트리, 해쉬s
	
	TMap -> key, value가 있음 -> unordered_map
	
	언리얼 엔진의 메모리 관리
	Mark-Sweep방식을 사용하며 성능을 위해 병렬처리, 클러스터링 등의 기법을 지원함
	GUObjectArray에 관리되는 언리얼 오브젝트의 정보를 저장한다. -> Garbage RootSet 플레그를 참조해 삭제 여부를 결정
		Garbage : 다른 언리얼 오브젝트로부터 참조가 없어 회수 예정인 오브젝트
		RootSet : 다른 언리얼 오브젝트로부터 참조가 없어도 회수하지 않는 특별한 오브젝트
	
	클래스 멤버 변수를 UPROPERTY로 참조할 경우 메모리가 회수되지 않는다.
	그럼 뭘 관리하는거냐 이놈은...
	
	w직렬화
	오브젝트를 바이트 스트림으로 변환하는 과정 FArchive 클래스를 찾아보자